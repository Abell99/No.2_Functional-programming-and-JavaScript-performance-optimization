# JavaScript性能优化

> 如何编写高性能的JavaScript

# 1~什么是性能优化？

## 1.1~性能优化介绍

- ##### 性能优化是不可避免的

- ##### 哪些内容可以看做是性能优化

  > 无处不在的前端性能优化

  - 请求资源时候所用到的网络
  - 数据的传输方式
  - 开发使用的框架

- ##### 本章所学习的优化内容：

  - #### **JavaScript语言的优化**

    - ##### 内存管理

    - ##### 垃圾回收与常见的GC算法

    - ##### V8引擎的垃圾回收

    - ##### Performance工具

    - ###### 代码优化实例

# 2~内存管理

> 善待内存从我做起

## 2.1~内存管理介绍

- 内存：由可读写单元组成，表示一片可以操作空间
- 管理：人为的取操作一片空间的申请，使用和释放

- 内存管理：开发者主动申请空间，使用空间，释放空间

- 基本的内存管理代码实现

  ```js
  // 申请内存
  let obj = {}
  
  // 使用内存, 内存的读写操作
  obj.name = 'abel'
  
  // 释放内存
  obj = null
  ```

# 3~垃圾回收与GC算法

> 收垃圾的也要好好学算法

## 3.1~JavaScript中的垃圾回收

> 对于前端开发者来说：
>
> - JavaScript中的内存管理是自动的

- ##### 什么是垃圾？

  > 划定一个范围，不符合标准的都是垃圾

  - 对象不再被**引用**的时候

  - 对象不能**从根上访问**到的时候

    - 能访问到的对象被称为**可达对象**（引用，作用域链）

    - 可达的标准就是从**根**出发是否能够被找到
      - JavaScript中的根就可以理解为是**全局变量对象**(全局执行上下文)

- ##### 应用与可达对象

  > 模拟一个垃圾的产生

  - 图示说明

    ![](C:\Users\Abel\AppData\Roaming\Typora\typora-user-images\image-20200603065305610.png)

  - 可达对象代码实现

    ```js
    function objGroup(obj1, obj2) {
        obj1.next = obj2
        obj2.prev = obj1
        return {
            o1: obj1,
            o2: obj2
        }
    }
    let obj = objGroup({name: 'obj1'}, {name: 'obj2'})
    console.log(obj)
    ```

  - 分析
    - 无论是obj还是o1,o2都可以从全局出发访问到
    - 但是如果置空obj，o1,o2就不再可达，就成为了垃圾

## 3.2~GC算法

> GC:垃圾回收机制的简写

- ##### GC的定义与作用

  - GC可以找到内存中的垃圾，并释放和回收空间
    - GC中认定的垃圾
      - 程序中不再需要使用的对象
      - 程序中不能再被访问到的对象

- ##### GC算法

  - GC是一种机制，垃圾回收器完成具体的工作
  - 工作的内容就是查找垃圾释放空间，回收空间
  - 算法就是工作时查找和回收所遵循的规则

- ##### 常见的GC算法

  - 引用计数
  - 标记清除
  - 标记整理
  - 分代回收

### 3.2.1~引用计数算法实现原理

- ##### 核心思想

  - 设置引用数，判断当前引用是否为0

- ##### 引用计数器

  - 当引用关系改变时修改引用数字

  - 引用为0时立即回收

- ##### 引用计数算法的优缺点

  - 优点
    - 发现垃圾时立即回收
    - 最大限度减少程序暂停
  - 缺点
    - 无法回收循环引用的对象
    - 时间，资源开销大

- ##### 引用计数的代码实现

  ```js
  const user1 = {age: 11}
  const user2 = {age: 22}
  const user3 = {age: 33}
  // 再次引用，引用计数加一
  const nameList = [user1.age, user2.age, user3.age]
  
  function fn() {
      const num1 = 1
      const num2 = 2
  }
  // 当函数执行完毕之后，内部的值引用为零，即被销毁
  fn()
  
  
  // 引用计数之殇
  // 循环引用
  function fn() {
      const obj1 = {}
      const obj2 = {}
      obj1.name = obj2
      obj2.name = obj1
      return '从根上找不到，却再局部作用域中有互相的访问'
  }
  fn()
  ```

### 3.2.2~标记清除算法实现原理

> 只标记可达对象， 不可达的都是垃圾

- ##### 核心思想

  - 分标记和清除两个阶段完成
  - 遍历所有对象并标记活动对象
  - 遍历所有对象清除没有标记的对象
  - 回收相应的空间

- ##### 标记清除图示

  ![image-20200603073311691](C:\Users\Abel\AppData\Roaming\Typora\typora-user-images\image-20200603073311691.png)

- ##### 标记清除算法的优缺点

  - 优点

    - 解决了引用计数算法的对象循环引用的回收问题

  - 缺点

    - 不会立即回收垃圾对象

    - 空间碎片化

      - 由于回收的垃圾对象再地址中是不连续的，所以回收的地址空间也是碎片化的

      - 图解

      ![image-20200603085512578](C:\Users\Abel\AppData\Roaming\Typora\typora-user-images\image-20200603085512578.png)

### 3.3.3~标记整理算法

> 回收垃圾中后也要好好整理空间以便后续的使用

- ##### 标记整理的核心思想
  - 标记整理可以看做是标记清除的增强
  - 标记阶段的操作和标记清除一致
  - 清除阶段会先执行整理，移动对象位置

- ##### 标记整理的优缺点

  - 优点
    - 减少碎片化空间
  - 缺点
    - 不会立即回收垃圾对象

# 4~V8引擎

> V8是一款主流的JavaScript执行引擎

- V8的特点

  - 采用**即时编译**
    - 源码→机器码

  - 内存受限

    > 完全够用，且可以优化垃圾回收

    - 64位：不超过1.5G
    - 32位：不超过800M

## 4.1~V8垃圾回收策略

> V8对于垃圾的回收，厂房空间受限，新旧存储区采取不同的算法

- ##### 核心思想

  - 采用分代回收的思想

    - 内存分为**新生代、老生代两个内存空间**
      - 小空间用于存储新生代对象(32M|16M)
    - 针对不同对象采用不同算法

    - V8垃圾回收图解

      ![image-20200603092235859](C:\Users\Abel\AppData\Roaming\Typora\typora-user-images\image-20200603092235859.png)

- ##### V8中常用的CG算法

  - 分代回收
  - 空间复制
  - 标记清除
  - 标记整理
  - 标记增量

## 4.2~V8回收新生代对象

> 针对新生代存储区的垃圾回收操作

- ##### 核心思想

  - 新生代指的是存活时间较短的对象

    > 例如局部作用域中的对象

  - 回收过程采用**复制算法+标记整理**

  - 新生代内存区分为两个等大的空间

    - 使用空间为From，空闲空间为To

    - 活动对象存储于From空间

      > 当From空间应用到一定程度，触发GC操作

    - 标记整理后将活动对象拷贝至To

      - 在拷贝过程中可能出现**晋升**

        > 晋升就是将新生代对象移动至老年代

      - 经过一轮GC还存活的新生代需要晋升
      - 如果To空间的使用率超过25%则本次GC操作的所有活动对象都移动至老生代

    - From与To交换空间完全释放
      - 这一步将所有的活动对象挪出了from区域，并清空from完成回收

##  4.3~V8如何回收老生代对象

> 老年活动中心的处理

- ##### 核心思想

  - 老年代对象存放在右侧的老生代区域

  - 64位操作系统1.4G，32位操作系统700M

  - 老年代对象就是存活时间较长的对象

    > 例如全局对象，闭包

  - 主要采用标记清除、标记整理、增量标记算法

    - 首先使用标记清除完成垃圾空间的回收(速度第一)

    - 采用标记整理进行空间优化

      > 发起晋升的时候，如果出现空间不足，就进行空间优化

    - 采用增量标记进行效率优化

- ##### 新老细节对比

  - 新生代区域垃圾回收使用空间换时间

    - 复制算法，保证空闲空间始终存在，由于空间小，所以很容易就进行复制，从而带来存储速度的提升

  - 老生代区域垃圾回收不适合复制算法

    - 空间大，一分为二浪费资源

    - 存储资源多，复制得不偿失

- ##### 标记增量优化

  - 图解

    ![image-20200603100252987](C:\Users\Abel\AppData\Roaming\Typora\typora-user-images\image-20200603100252987.png)

  - 核心理解
    - 将一整个的垃圾回收操作，拆分为多个小的部分，垃圾回收和程序交替执行
      - 使程序执行的时候，划分出一些时间用来进行垃圾回收

# 5~Performance工具

> GC:
>
> - GC的目的就是为了实现内存空间的良性循环
>
> - 良性循环的基石是合理使用
> - **时刻关注**才能确定是否合理
>
> 而Performance就是帮助我们来时刻关注内存变化的

- ##### 通过Performance可以时刻监控内存

- ##### Performance的使用步骤

  - 打开浏览器输入目标网址
  - 进入开发人员工具面板，选择性能
  - 开启录制功能，访问具体界面
  - 执行用户行为，一段时间后停止录制
  - 分析界面中记录的内存信息

## 5.1~内存问题的体现

> 问题的定位

- ##### 页面出现延迟加载或经常性暂停

  - 频繁的垃圾回收操作

- ##### 页面持续性出现糟糕的性能

  - 内存膨胀

- ##### 页面的性能随时间延长越来越差

  - 内存泄漏

## 5.2~监控内存的几种方式

> 快速判断问题，从而更好的解决问题

- ##### 界定内存问题的标准

  - 内存泄漏
    - 内存使用持续升高
  - 内存膨胀
    - 在多数设备上都存在性能问题
  - 频繁的垃圾回收
    - 通过内存变化图进行分析

- ##### 监控内存的几种方式

  - 浏览器任务管理器
    - `shift + esc`
  - TimeLine时序图记录
  - 堆快照查找分离DOM
    - 分离DOM就是一种内存泄漏
  - 判断是否存在频繁的垃圾回收
    - 通过各种内存走势图判断

## 5.3~任务管理器监控内存

> 判断问题

- 模拟一个耗时操作

  ```js
  oBtn.onclick = function() {
          let arrList = new Array(10000)
      }
  ```

![image-20200603105342726](C:\Users\Abel\AppData\Roaming\Typora\typora-user-images\image-20200603105342726.png)

## 5.4~TimeLine记录内存

> 定位问题

- 根据时序，判断是哪一部分操作引起的内存变化

![image-20200603110555002](C:\Users\Abel\AppData\Roaming\Typora\typora-user-images\image-20200603110555002.png)

## 5.5~堆快照查找分离DOM

> 拍个照片来分析，清空deta

- ##### 什么是分离DOM

  - 界面元素存活在DOM树上
  - 垃圾对象时的DOM节点
  - 分离状态的DOM节点

- ##### 快照

  ![image-20200603112208862](C:\Users\Abel\AppData\Roaming\Typora\typora-user-images\image-20200603112208862.png)

## 5.6~判断是否存在频繁的GC

> 垃圾回收和应用程序不能同步执行，所以不能太频繁

- ##### 为什么要确定频繁垃圾回收

  - GC工作时应用程序时停止的
  - 频繁且过长的GC会导致应用假死
  - 用户使用中感知应用卡顿

- ##### 确定频繁 的垃圾回收

  - Timeline中频繁的上升下降
  - 任务管理器中数据频繁的增加减少

# 6~代码优化

> 如何写出更好的脚本

- 如何精准测试JavaScript性能
  - 本质上就是采集大量的执行脚本进行数学统计和分析
  - 使用基于Benchmark.js的[Jsperf](https://jsperf.com/)完成

- Jsperf的使用流程

  - 使用GitHub账户登录
  - 填写个人信息(非必须)
  - 填写详细的测试用例信息
    - title
    - slug
  - 填写准备代码
    - DOM操作时经常使用
  - 填写必要的setup与teardown代码

  - 填写测试代码片段

## 6.1~慎用全局变量

> 不是必须的不用全局变量

- 全局变量
  - 全局变量定义在全局执行上下文，是所有作用域链的顶端
    - 作用域链查找是从下往上的，全部都在全局，太耗时间
  - 全局执行上下文一直存在于上下文执行栈，直到程序退出
    - 不利于GC工作，影响内存使用
  - 如果某个局部作用域出现了同名变量，则会遮蔽或者污染全局
    - 全局的变量，被某个局部作用域做出了修改，不容易确定来源

## 6.2~缓存全局变量

> 将使用中无法避免的全局变量缓存到局部

- 什么是缓存全局变量

  - 将需要频繁调用的全局变量赋值给一个局部的新的变量
    - 原理：使每次调用全局变量根据作用域链的原理，更近了一点

  - 例如

    ```js
    function getBtn() {
    	let obj = document    
    }
    ```

## 6.3~通过原型链新增方法

> 问题：
>
> - 为什么添加的地方不一样，会有性能上的差异？

- 在原型对象上新增实例对象需要的方法
- 原型链上的方法只有一个，所有的实例化对象访问的都是一个内存资源，所以节省内存

## 6.4~避开闭包陷阱

> 开始沉思编程式函数频繁使用的闭包操作是否进入了陷阱？

- ##### 闭包的特点

  - 外部具有指向内部的引用
  - 在’外‘部作用域访问’内‘部作用域的数据

  - 例如

    ```js
    function foo(){
        var name = 'abel'
        function fn(){
            console.log(name)
        }
        return fn
    }
    var a = foo()
    a()
    ```

- ##### 关于闭包

  - 闭包使一种强大的语法
  - 闭包使用不当很容易出现内存泄漏
  - 不要为了闭包而闭包

- ##### 闭包的陷阱

  - 重复引用已存在的节点

  - 解决方法，例如

    ```js
    function foo() {
        // 重复引用了页面中已存在的节点，如果删除了该节点，会因为引用计数的问题，仍然占有内存
        var el = document.getElementById('btn')
        el.onclick = function() {
            console.log(el, id)
        }
        
        // 所以需要最后将该引用置位null
        el = null
    }
    foo()
    ```

## 6.5~避免属性访问方法使用

> JavaScript中的面向对象有些许不同

- ##### JavaScript中的面向对象

  - js不需要属性的访问方法，所有属性都是外部可见的
  - 使用属性访问方法只会增加一层重定义，没有访问的控制力

## 6.6~For循环优化

> for循环的正确打开方式

- ##### 声明长度，避免重复获取

- 示例

  ```js
  for (var i = 0, len = arr.length; i < len; i++) {
      console.log(arr[i])
  }
  ```

## 6.7~选择最优的循环方法

> 循环方法的优胜略汰，强弱领域判断

- ##### 有图有真相，遍历同一组数组

![image-20200603130706046](C:\Users\Abel\AppData\Roaming\Typora\typora-user-images\image-20200603130706046.png)

- ##### 性能排序：foreach > for > forin

## 6.8~节点添加优化

> 节点的添加操作必然会有回流和重绘
>
> 如何优化，就是针对这两者进行的优化

- ##### 文档碎片优化节点添加

  > 在循环中不直接向页面中的元素添加元素，而是通过一个中间元素容器，组合文档碎片在循环结束后统一添加

   ```js
  const fragEle = document.createDocumentFragment()
  for (var i = 0; i < 10; i++) {
      var op = document.createElement('p')
      oP.innerHTML = i
      fragEle.appendChild(oP)
  }
  document.body.appendChild(fragEle)
   ```

## 6.9~克隆优化节点操作

> 生的没有克隆的快

- 需要循环多次创建同一元素的话，可以先创建一个，其余的克隆

  ```js
  var oldP = document.createElement('p')
  for (var i = 0; i < 3; i++) {
      var newP = oldP.cloneNode(false)
      newP.innerHTML = i
  	document.body.appendChild(newP)
  }
  ```

## 6.10~直接量替换new object操作

> 优先使用字面量，方便快捷还又好

- 请使用字面量声明变量

